#+hugo_base_dir: ../
#+hugo_auto_set_lastmod: t

* 耶复活了 :随笔:
:PROPERTIES:
:EXPORT_FILE_NAME: hello-world-again
:EXPORT_HUGO_SECTION: posts
:EXPORT_DATE: 2025-02-15T23:21:03+08:0
:END:

之前用 =hexo= 构建的博客遗失了，目前先使用 =github pages= + =hugo= 构建博客。
将来大概会用 =cloudflare pages= + =org mode= + 自己用 =elisp= 写的博客引擎重构。

+耶复活了。+

* A64指令集編碼 :VM:ASM:ARM:
:PROPERTIES:
:EXPORT_FILE_NAME: a64-instruction-encoding
:EXPORT_HUGO_SECTION: posts
:EXPORT_DATE: <2025-03-15 Sat>
:END:

最近在做 Aarch64 架構的虛擬機，在此分享一下 A64 的指令編解碼。

儘管 A64/A32 指令集是由若干 /FEAT_XXX/ 組成的，但 Arm 還是將其分為了若干類以便於拓展和編解碼。大概可以分為：
1. 基本指令集
2. 浮點數和 SIMD 指令集
3. 向量指令集
4. 矩陣指令集

在編解碼時由指令了 *[25:28]* 位決定其分類，具體的分類見下表：

| Instr[28:25]           | 對應指令集分類                                                           |
|------------------------+--------------------------------------------------------------------------|
| 0b0000 (Instr[31] = 0) | 保留                                                                     |
| 0b0000 (Instr[31] = 1) | 矩陣指令集 (SME)                                                         |
| 0b0010                 | 向量指令集 (SVE)                                                         |
| 0b100x                 | 數據通路 (Data Processing)：立即數類                                     |
| 0b101x                 | 分支指令、異常生成 (Exception Generating)、系統指令 (System instruction) |
| 0bx101                 | 數據通路 (Data Processing)：寄存器類                                     |
| 0bx111                 | 數據通路 (Data Processing)：浮點數以及 SIMD 指令集                       |
| 0bx1x0                 | 內存加載和儲存 (Loads and Store)                                         |

下面簡單分享一下基本指令集和浮點、SIMD 指令集的編解碼規則，後續有機會分享一下 SVE 以及 SME 指令集的編解碼。
** 數據通路 - 寄存器類

這一類指令類型主要涵蓋了：
1. *邏輯運算*: 比如 /AND/, /ORR/ 等。
2. *算數運算*: 比如 /ADD/, /ADC/, /SBC/ 等。
3. *條件運算*: 比如 /CSEL/, /CCMP/ 等。
4. *其他的特殊操作*: 通常由處理器實現的 FEAT 相關，編解碼時由 *操作數* 數量區分。

具體的編碼表如下：

| Instr[28] | Instr[24:21]                       | Instr[15:10] | 相應指令分類                                                     |
|-----------+------------------------------------+--------------+------------------------------------------------------------------|
|         0 | 0b0xxx                             |              | 邏輯運算 (shifted register 類)                                   |
|         0 | 0b1xx0                             |              | 加減運算 (shifted register 類)                                   |
|         0 | 0b1xx1                             |              | 加減運算 (extended register 類)                                  |
|         1 | 0b0000                             | 0b000000     | 加減運算 (with carry 類)                                         |
|         1 | 0b0000                             | 0b001xxx     | 加減運算 (checked pointer 類，用於檢查指針運算是否超出範圍)      |
|         1 | 0b0000                             | 0bx00001     | Rotate right into flags 類 (數值右旋並改變處理器的 flags)        |
|         1 | 0b0000                             | 0bxx0010     | Evaluate into flags 類 (條件測試並改變處理器的conditional flags) |
|         1 | 0b0010                             | 0bxxxx0x     | 條件比較 (寄存器類)                                              |
|         1 | 0b0010                             | 0bxxxx1x     | 條件比較 (立即數類)                                              |
|         1 | 0b0100                             |              | 條件選擇 (例如 CSEL，允許根據條件標誌選擇不同的寄存器值)         |
|         1 | 0b0110, Instr[28]=0, Instr[30] = 1 |              | 單源操作數數據通路                                               |
|         1 | 0b0110, Instr[28]=0, Instr[30] = 0 |              | 雙源操作數數據通路                                               |
|         1 | 0b1xxx                             |              | 三源操作數數據通路                                               |

** 數據通路 - 立即數類
| Instr[30:29] | Instr[25:22] | 指令分類                                   |
|--------------+--------------+--------------------------------------------|
|              | 0b00xx       | PC 相對尋址 (PC-rel. addressing)           |
|              | 0b010x       | Add/substract                              |
|              | 0b0110       | Add/substract (with tags)，用於 *MTE* 拓展 |
|              | 0b0111       | Min/max                                    |
|              | 0b100x       | Logical                                    |
|              | 0b101x       | Move wide                                  |
|              | 0b110x       | Bitfield                                   |
| Not 0b11     | 0b111x       | Extract                                    |
| 0b11         | 0b111x       | 單源操作數數據通路                         |
** 內存加載和儲存
A64 有著極為獨特訪存模式以及豐富的訪存拓展，因此 Load/store 指令的數量也極為龐大。即使是基本 Load/store 指令，也有著不同的偏移量訪存模式。同時不同的特權級 (EL) 也有特定的訪存指令，而且拓展指令集也會帶來各自的訪存指令 (比如 SIMD)。因此會有一個特別上的 tag 段來進行編解碼。這裡給出相關的 Load/store 種類，而不給出具體的編解碼表。

1. 偏移量種類: 可以分為 /unsigned immediate/, /unscaled immediate/, /register offset/, /pre-indexed/, /post-indexed/ 等種類。
2. 成對加載/存儲: 比如 =LDP/STP= ，適用於 64-bit、128-bit。
3. 互斥訪存: 適用於多處理器環境中的 *同步與互斥* ，比如獨佔訪問 (=LDXR/STXR= exclusive register)、Compare and Swap (=CAS=)、Release-Compare-Write (=RCW CAS=)。
4. 內存順序保證 (/Ordered/): 這類指令確保訪存順序，通常用於內存屏障和同步機制。比如 (=STLR= store-release, =LDAPR= load-acquire)
5. Memory Tagging: Arm 引入了 /Memory Tagging Extension (MTE)/ 機制用於內存安全檢查。比如 (=LDG/STG= load/store tags)
6. 原子操作: 比如原子加法 (=LDADD/STADD=)，原子復位 (=LDCLR/STCLR=) 等。

一些 Armv8 的 FEAT 也會引入特殊用途的訪存指令，比如 /Pointer Authentication Code/, /General Capability System/ 等。
** 分支指令、異常生成和系統指令

/Branches, Exception Generating, and System Instructions/ 指令集大概可以分為一下幾類並以此編解碼：
1. *分支指令*: 包括條件、無條件分支、基於比較的分支等，同時也可以根據源操作數種類進行劃分。
2. *異常生成指令*: 這些指令用於產生異常 (/Exception/)，以實現系統調用、調試或錯誤處理。包括： =SVC=, =HVC=, =BRK= 等等。
3. *System Instructions (系統管理指令指令)* : 這類指令用於 _訪問處理器狀態 (/PSTATE/)_ 、 _執行特殊操作_ 、 _同步內存_ 等。
4. *Hints & Barriers*: 在 A64 系統指一些 *影響* CPU 的行為，但不會改變程式的 *邏輯結果* 。比如 /NOP/, /WFE/ 等 Hints 指令以及 /DSB/, /DMB/ 等內存屏障指令

由於這類指令數量較多且極易和常常拓展，同時理論上不需要多少源操作數，A64 足足用了 Instr[31:29] 和 Instr[25:12] 這麼長的譯碼空間。

** 浮點數、SIMD 指令
總得來說，A64 的 /Scalar Floating-Pointe and Advanced SIMD/ 可以分為三大類指令:
1. Cryptographic
2. Advenced SIMD
3. Floating-Point

Cryptographic 是大概分為 AES 和 SHA，並根據算法複雜性和步驟分為不同寄存器數量的指令 (如 two/three/four-register) 。

浮點數指令則分為 *Convention* 和浮點數的 *Data processing* ， /Advanced SIMD/ 則涉及一些更為復雜的數據通路及指令，比如 /across lanes/ (對整個向量求和或取最大值等)、 /table lookup/ 、 /permute/ 等

* 如何制作 X-Face 风格头像 :Emacs:nerd:
:PROPERTIES:
:EXPORT_FILE_NAME: how-to-make-and-use-xface
:EXPORT_HUGO_SECTION: posts
:EXPORT_DATE: 2025-02-17T01:23:06+08:00
:END:


一开始是在 /emacs-china/ 上水论坛时，经常能看到像素极低、纯黑白的头像、却又很带感的头像。后来[[https:emacs-china.org/t/topic/3118][发现]]原来叫 =X-face= ，大概是邮件／新闻组时代流行的头像。

#+begin_quote
翻到 [[https://blog.csdn.net/lujun9972/article/details/46002803][DarkSun转的一篇老文章]]，提到了 [[https://en.wikipedia.org/wiki/X-Face][X-Face]] 这个邮件／新闻组时代很流行的东西。就和现在的 Gravatar 差不多。甚至以前的 IRC 也能显示 X-face 头像。
#+end_quote

=X-face= 是邮件 header 部分嵌入的一段代码，在读入邮件时转换为 /48x48/ 的 bitmap。可以通过 [[https://www.dairiki.org/xface/xface.php][Online X-Face Converter]] 直接转换。然而，如果你的图片是彩色的、分辨率过高，直接转换的效果很不好。

这里参考了 [[https://emacs-china.org/t/x-face/28144][emacs-china 上的一个教程]]，分享一下作为 =gimp= 苦手的制作过程。

1. 图像->模式->灰度：将彩色的图片去色便于后续通过 *阈值* 分割像素，当然最好用本来就是黑白的图片。
2. 颜色->阈值：这一步将黑白像素分离，只要有线条即可，后续通过滤镜加粗线条。这里建议可以分图层处理，比如说眼睛部分和头发部分，往往当眼睛部分已经全为黑色像素时头发的线条还未区分。
3. 图像->模式->索引：将图片变为 /black and white pattle(1bit)/
4. 滤镜->常规->腐蚀：将线条加粗，一般需要多次使用这个滤镜。
5. 图像->缩放：缩放为 48x48 ，插值方法一般不限。

据 [[https://emacs-china.org/t/x-face/28144/2][LdBeth]]，x-face 没有确切的解码标准，甚至因为作者技术问题和导致仿造实现时出了偏差，有些实现是相互不兼容的，现在一般用 compface 这个具体实现。这里直接使用 /compface/ 提供的 =xbm2xface= 脚本即可。或者直接使用 [[https://www.dairiki.org/xface/xface.php][Online X-Face Converter]] encode一下。

** 为 WanderLust 设置 X-Face 邮件头

/WanderLust/ 自动读取 =~/.xface= ，如果需要显示 X-Face 则需要额外的包，参考了 =doom emacs= ，添加：

#+begin_src elisp
  ;; Use x-face only when compface installed
  (when (modulep! +xface)
    (autoload 'x-face-decode-message-header "x-face-e21")
    (setq wl-highlight-x-face-function 'x-face-decode-message-header))
#+end_src

顺便一提， =Homebrew= 目前不提供 =compface= 这个包，这里参考 [[https://www.linuxfromscratch.org/blfs/view/git/general/compface.html][Linux® From Scratch]] 手动构建了这个程序。你可能需要：

#+begin_src shell
sed -e '/compface.h/a #include <unistd.h>' \
    -i cmain.c                             \
    -i uncmain.c
#+end_src

才能构建成功。
* [譯] 高效文本编辑的七个习惯 :Emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: seven-habits-of-effective-text-editing
:EXPORT_HUGO_SECTION: posts
:EXPORT_DATE: <2025-03-15 Sat>
:END:

如果你花费大量时间输入纯文本、编写程序或HTML，那么通过使用一款优秀的编辑器并高效地使用它，你可以节省大量时间。本文将提供一些指导和建议，帮助你更快地完成工作并减少错误。

这里将使用开源文本编辑器Vim（Vi IMproved）来展示高效编辑的理念，但这些理念同样适用于其他编辑器。 _选择一款合适的编辑器_ 实际上是实现高效编辑的第一步。关于哪款编辑器最适合你的讨论会占用太多篇幅，因此这里不做展开。如果你不知道该使用哪款编辑器，或者对当前使用的编辑器不满意，不妨试试Vim /（譯者：不妨試試 *Emacs* ）/ ；你不会失望的。

#+begin_quote
原文標題：Seven habits of effective text editing

原文鏈接：[[https://www.moolenaar.net/habits.html]]

原文作者：[[https://www.moolenaar.net][Bram Moolenaar]]
#+end_quote

** Part 1: 單文件編輯
*** 1. 快速移动

在編輯文本時，大多数时间都花在 *阅读* 、 *检查错误* 以及 *寻找需要编辑的位置* 上，而不是插入或修改新文本。由于在文本中导航是非常频繁的操作，因此你应该学会如何 _快速移动_ 。

很多时候，你会想要搜索一些你知道存在的文本，或者查看某个单词或短语出现的所有行。你可以简单地使用搜索命令 =/pattern= 来查找文本，但还有更聪明的方法：

- 如果你看到一个特定的单词，并想搜索该单词的其他出现位置，可以使用 =*= 命令。它会从光标下提取单词并搜索下一个匹配项。
- 如果你设置了 =incsearch= 选项，Vim 会在你输入模式时显示第一个匹配项。这可以快速发现模式中的 _拼写错误_ 。
- 如果你设置了 =hlsearch= 选项，Vim 会用黄色背景高亮显示所有匹配项。这可以快速预览搜索命令会带你到哪里。在程序代码中，它可以显示变量的 _使用位置_ 。你甚至不需要移动光标就能看到匹配项。

在 /结构化文本/ 中，还有更多快速移动的可能性。Vim 为 C 语言（以及类似语言如 C++ 和 Java）提供了特定的命令：

- 使用 =%= 可以从一个开括号跳转到其匹配的闭括号，或者从 =#if= 跳转到匹配的 =#endif= 。实际上， =%= 可以跳转到许多不同的匹配项。它对于检查 =()= 和 ={}= 结构是否平衡非常有用。
- 使用 =[{= 可以跳回到当前代码块开头的 ={= 。
- 使用 =gd= 可以从变量的使用位置跳转到其局部声明。

当然，还有很多其他命令。关键在于你需要熟悉这些命令。你可能会反对说，你不可能学会所有这些命令——有数百种不同的移动命令，有些简单，有些非常巧妙——而且需要数周的训练才能掌握它们。其实你不需要 *全部学会* ；相反，你应该意识到自己的编辑方式，并只学习那些 _能让你的编辑更高效的命令_ 。

以下是三个基本步骤：

1. 在编辑时，留意你重复执行的操作或花费大量时间的操作。
2. 查找是否有编辑器命令可以更快地完成这些操作。阅读文档、询问朋友，或者观察其他人是如何做的。
3. 练习使用这些命令，直到你能不假思索地输入它们。

让我们通过一个例子来说明它是如何工作的：

- 你发现自己在编辑 C 程序文件时，经常花费时间寻找函数的定义位置。你目前使用 =*= 命令搜索函数名的其他出现位置，但最终会浏览许多函数使用的位置，而不是定义位置。你意识到一定有更快的方法。
- 浏览快速参考时，你发现了一个关于跳转到标签的备注。文档展示了如何用它跳转到函数定义，这正是你想要的！
- 你尝试使用 Vim 自带的 =ctags= 程序生成标签文件。你学会了使用 =CTRL-]= 命令，并发现它节省了大量时间。为了更方便，你在 Makefile 中添加了几行代码，以自动生成标签文件。

在使用这三个步骤时，需要注意以下几点：

- “我想完成工作，没时间查阅文档找新命令”。如果你这样想，你会停留在计算的石器时代。有些人用记事本做所有事情，然后奇怪为什么其他人能在一半的时间内完成工作…… 不要過猶不及。如果你总是试图为每一件小事找到完美的命令，你的大脑将没有时间思考你实际在做的工作。只需挑选那些花费不必要时间的操作，并练习这些命令，直到使用时无需思考。然后你就可以专注于文本了。

在接下来的部分中，将提供一些大多数人需要处理的操作建议。你可以将这些作为灵感，将 *三个基本步骤* 应用到自己的工作中。

*** 2. 不要重复输入

我们输入的单词是有限的，甚至短语和句子也是有限的，尤其是在计算机程序中。显然，你不想重复输入相同的内容。

很多时候，你会想将一个单词更改为另一个单词。如果需要在整个文件中进行更改，可以使用 =:s= （替换）命令。如果只需要更改少数位置，快速的方法是使用 =*= 命令找到下一个匹配项，并使用 =cw= 更改单词。然后按 =n= 找到下一个单词，并按 =.= （点）重复 =cw= 命令。

=.= 命令会重复上一次的更改。在这里，“更改”指的是插入、删除或替换文本。能够重复这一操作是一个非常强大的机制。如果你围绕它组织编辑，许多更改将只需按一下 =.= 键即可完成。注意不要在中间进行其他更改，因为它会替换你正在重复的更改。相反，你可以使用 =m= 命令标记位置，继续重复更改，稍后再回到那里。

某些函数和变量名可能很难输入。你能快速无误地输入 =XpmCreatePixmapFromData= 而不看参考吗？ Vim 有一个补全机制，可以让这变得容易得多。它会查找你正在编辑的文件中的单词，以及 =#include= 的文件中的单词。你可以输入 =XpmCr= ，然后按 =CTRL-N= ，Vim 会将其扩展为 =XpmCreatePixmapFromData= 。这不仅节省了大量输入，还避免了拼写错误，以及编译器报错后需要修复的麻烦。

当你需要多次输入一个短语或句子时，有一种更快的方法。Vim 有一个录制宏的机制。你可以输入 =qa= 开始录制到寄存器 =a= 中，然后像平常一样输入命令，最后按 =q= 停止录制。当你想重复录制的命令时，输入 =@a= 。共有 26 个寄存器可用于此操作。

通过录制，你可以重复许多不同的操作，而不仅仅是插入文本。当你知道要重复某些操作时，请记住这一点。

录制时需要注意的一点是，命令会完全按照你输入的方式回放。在移动时，你必须记住，重复命令时，移动的文本可能会有所不同。向左移动四个字符在录制时可能有效，但在重复命令时可能需要移动五个字符。通常需要使用命令移动文本对象（单词、句子）或移动到特定字符。

当需要重复的命令变得更复杂时，一次性正确输入它们会变得更加困难。这时，你应该编写脚本或宏，而不是录制它们。这对于创建代码部分的模板非常有用，例如函数头。你可以根据需要使其尽可能智能。

*** 3. 快速修復錯誤

在输入时犯错是很正常的，没有人能避免。关键在于快速发现并纠正这些错误。编辑器应该能够帮助你做到这一点，但你需要告诉它什么是错的，什么是对的。

很多时候，你会一次又一次地犯同样的错误。你的手指就是没有按你的意图行事。这可以通过缩写来纠正。以下是一些例子：

#+begin_src vim
:abbr Lunix Linux
:abbr accross across
:abbr hte the
#+end_src

这些单词会在你输入后自动更正。

同样的机制也可以用来通过几个字符输入一个长单词。这对于你难以输入的单词特别有用，同时也能避免输入错误。例如：

#+begin_src vim
:abbr pn penguin
:abbr MS Mandrake Software
#+end_src

然而，这些缩写有时会在你不希望的时候扩展为完整单词，这在你确实想在文本中插入“MS”时会变得困难。最好使用没有独立意义的短单词。

为了发现文本中的错误，Vim 有一个智能的高亮机制。这原本是用于程序语法高亮的，但它也可以捕捉并高亮错误。

语法高亮会用颜色显示注释。这听起来不像是一个重要的功能，但一旦你开始使用它，你会发现它非常有帮助。你可以快速发现应该是注释但没有被高亮的文本（可能是你忘记了注释标记），或者看到一行代码被高亮为注释（你可能忘记插入 =*/= ）。这些错误在黑白文件中很难发现，可能会在调试代码时浪费大量时间。

语法高亮还可以捕捉不平衡的括号。一个不平衡的 =)= 会用亮红色背景高亮显示。你可以使用 =%= 命令查看它们如何匹配，并在正确的位置插入 =(= 或 =)= 。

其他常见错误也能快速发现，例如使用 =#included <stdio.h>= 而不是 =#include <stdio.h>= 。在黑白文件中，你很容易忽略这个错误，但通过高亮，你可以快速发现 =include= 被高亮而 =included= 没有。

一个更复杂的例子：对于英文文本，有一个包含所有使用单词的长列表。任何不在这个列表中的单词都可能是错误的。通过语法文件，你可以高亮所有不在列表中的单词。通过一些额外的宏，你可以将单词添加到单词列表中，这样它们就不会再被标记为错误。这与你在文字处理器中的预期效果一致。在 Vim 中，这是通过脚本实现的，你可以根据自己的需求进一步调整：例如，只检查程序中的注释是否有拼写错误。

** Part 2: 多文件編輯
*** 4. 文件很少单独存在

人们通常不会只处理一个文件。大多数情况下，会有许多相关的文件，你需要依次编辑多个文件，甚至同时编辑多个文件。你应该能够利用编辑器的功能，使处理多个文件更加高效。

前面提到的 tag 机制也适用于在文件之间跳转。通常的做法是为整个项目生成一个 tag 文件。然后，你可以在项目中的所有文件之间快速跳转，查找函数、结构体、typedef 等的定义。与手动搜索相比，这节省了大量时间；浏览程序时，我做的第一件事就是生成 tag 文件。

另一个强大的机制是使用 =:grep= 命令在一组文件中查找某个名称的所有出现位置。Vim 会列出所有匹配项，并跳转到第一个匹配项。 =:cn= 命令会将你带到下一个匹配项。如果你需要更改函数调用中的参数数量，这将非常有用。

頭文件（include files）中有很多有用的信息。但找到包含你所需声明的文件可能会花费大量时间。Vim 了解包含文件，并可以在其中搜索你正在查找的单词。最常见的操作是查找函数的原型。将光标放在文件中函数名称上，然后输入 =[I= ：Vim 会显示包含文件中该函数名称的所有匹配项。如果你需要查看更多上下文，可以直接跳转到声明处。类似的命令还可以用于检查你是否包含了正确的头文件。

在 Vim 中，你可以将文本区域分割成多个部分来编辑不同的文件。然后，你可以比较两个或多个文件的内容，并在它们之间复制/粘贴文本。有许多命令可以打开和关闭窗口、在窗口之间跳转、临时隐藏文件等。同样，你需要使用三个基本步骤来选择你想学习和使用的命令集。

多窗口还有更多用途。预览 tag 机制就是一个很好的例子。它会打开一个特殊的预览窗口，同时保持光标在你正在编辑的文件中。预览窗口中的文本会显示光标下函数名称的函数声明。如果你将光标移动到另一个名称并停留一秒钟，预览窗口将显示该名称的定义。它也可能是项目中包含文件中声明的结构体或函数的名称。

*** 5. 协同編輯

编辑器用于编辑文本，电子邮件程序用于发送和接收消息，操作系统用于运行程序。每个程序都有自己的任务，并且应该擅长于此。真正的力量来自于让这些程序协同工作。

一个简单的例子：你需要写一篇不超过 500 字的摘要。选择当前段落并将其写入 =wc= 程序： =vip:w !wc -w= 。外部的 =wc -w= 命令用于统计字数。很简单，不是吗？

总会有一些你需要的功能不在编辑器中。通过让编辑器能够用其他程序过滤文本，意味着你可以从外部添加这些功能。Unix 的精神一直是让独立的程序做好自己的工作，并协同完成更大的任务。不幸的是，大多数编辑器并不能很好地与其他程序协同工作——例如，你无法将 Netscape 中的电子邮件编辑器替换为另一个编辑器。最终你只能使用一个功能受限的编辑器。另一种趋势是将各种功能集成到编辑器中；Emacs 就是一个很好的例子。（有些人称其为“一个也可以用来编辑文本的操作系统”。）

Vim 试图与其他程序集成，但这仍然是一个挑战。目前，Vim 可以在 MS-Developer Studio 和 Sniff 中作为编辑器使用。一些支持外部编辑器的电子邮件程序（如 Mutt）也可以使用 Vim。与 Sun Workshop 的集成正在开发中。总的来说，这是一个在不久的将来需要改进的领域。只有这样，我们才能得到一个比各部分总和更好的系统。

*** 6. 文本结构

你经常会处理具有某种结构的文本，但这些结构与现有命令支持的结构不同。这时，你需要回到编辑器的“构建模块”，创建自己的宏和插件来处理这些文本。我们正在进入更复杂的内容。

其中一个较简单的任务是加速编辑-编译-修复的循环。Vim 提供了 =:make= 命令，它可以启动编译，捕获编译产生的错误，并让你跳转到错误位置进行修复。如果你使用不同的编译器，错误信息可能无法被识别。与其回到旧的“手动记录”系统，你应该调整 =errorformat= 选项。这告诉 Vim 你的错误信息是什么样子的，以及如何从中提取文件名和行号。它适用于复杂的 gcc 错误信息，因此你应该能够让它适用于几乎任何编译器。

有时，适应某种文件类型只需设置一些选项或编写一些宏。例如，要在手册页之间跳转，你可以编写一个宏，抓取光标下的单词，清空缓冲区，然后将该单词的手册页读入缓冲区。这是一种简单高效的查找交叉引用的方法。

使用三个基本步骤，你可以更有效地处理任何类型的结构化文件。只需思考你想对文件执行的操作，找到执行这些操作的编辑器命令，并开始使用它们。这真的像听起来那么简单。你只需要去做。

** Part 3: 必先利其器

*** 7. 养成习惯

学习开车需要付出努力。这是你继续骑自行车的理由吗？不，你意识到需要投入时间来学习一项技能。文本编辑也不例外。你需要学习新的命令并将其变成习惯。

另一方面，你不应该试图学习编辑器提供的每一个命令。那将完全是浪费时间。大多数人只需要学习 10% 到 20% 的命令来完成他们的工作。但每个人需要的命令集是不同的。这需要你时不时停下来思考，是否有某些重复性任务可以自动化。如果你只执行一次某个任务，并且不期望再次执行它，那就不要尝试优化它。但你可能会意识到，你在过去一小时里已经重复了某些操作好几次。这时，你应该查阅文档，寻找可以更快完成任务的命令，或者编写一个宏来实现它。如果是一个更大的任务，比如处理某种特定类型的文本，你可以在新闻组或互联网上看看是否有人已经为你解决了这个问题。

最关键的基本步骤是最后一步。你可能会想到一个重复性任务，找到一个很好的解决方案，但过了一个周末后，你却忘记了具体做法。这行不通。你必须重复使用这个解决方案，直到你的手指能够自动完成它。只有这样，你才能达到所需的效率。不要试图一次学习太多东西，但同时学习几件事是可行的。对于那些你不常使用、无法熟练掌握的技巧，你可以将它们写下来，以便以后查阅。无论如何，只要你心中有目标，你就会找到方法，让你的编辑变得越来越高效。

最后提醒一下，如果人们忽视以上所有建议，会发生什么：我仍然看到有些人每天花半天时间盯着屏幕，低头看着两根手指，再抬头看屏幕，如此反复——然后奇怪为什么他们会这么累…… *用十根手指打字* 这不仅更快，而且也更不容易疲劳。每天使用计算机程序一小时，只需要几周时间就能学会盲打。
