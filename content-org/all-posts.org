#+hugo_base_dir: ../
#+hugo_auto_set_lastmod: t

* 耶复活了 :随笔:
:PROPERTIES:
:EXPORT_FILE_NAME: hello-world-again
:EXPORT_HUGO_SECTION: posts
:EXPORT_DATE: 2025-02-15T23:21:03+08:0
:END:

之前用 =hexo= 构建的博客遗失了，目前先使用 =github pages= + =hugo= 构建博客。
将来大概会用 =cloudflare pages= + =org mode= + 自己用 =elisp= 写的博客引擎重构。

+耶复活了。+

* A64指令集編碼 :VM:ASM:ARM:
:PROPERTIES:
:EXPORT_FILE_NAME: a64-instruction-encoding
:EXPORT_HUGO_SECTION: posts
:EXPORT_DATE: <2025-03-15 Sat>
:END:

最近在做 Aarch64 架構的虛擬機，在此分享一下 A64 的指令編解碼。

儘管 A64/A32 指令集是由若干 /FEAT_XXX/ 組成的，但 Arm 還是將其分為了若干類以便於拓展和編解碼。大概可以分為：
1. 基本指令集
2. 浮點數和 SIMD 指令集
3. 向量指令集
4. 矩陣指令集

在編解碼時由指令了 *[25:28]* 位決定其分類，具體的分類見下表：

| Instr[28:25]           | 對應指令集分類                                                           |
|------------------------+--------------------------------------------------------------------------|
| 0b0000 (Instr[31] = 0) | 保留                                                                     |
| 0b0000 (Instr[31] = 1) | 矩陣指令集 (SME)                                                         |
| 0b0010                 | 向量指令集 (SVE)                                                         |
| 0b100x                 | 數據通路 (Data Processing)：立即數類                                     |
| 0b101x                 | 分支指令、異常生成 (Exception Generating)、系統指令 (System instruction) |
| 0bx101                 | 數據通路 (Data Processing)：寄存器類                                     |
| 0bx111                 | 數據通路 (Data Processing)：浮點數以及 SIMD 指令集                       |
| 0bx1x0                 | 內存加載和儲存 (Loads and Store)                                         |

下面簡單分享一下基本指令集和浮點、SIMD 指令集的編解碼規則，後續有機會分享一下 SVE 以及 SME 指令集的編解碼。
** 數據通路 - 寄存器類

這一類指令類型主要涵蓋了：
1. *邏輯運算*: 比如 /AND/, /ORR/ 等。
2. *算數運算*: 比如 /ADD/, /ADC/, /SBC/ 等。
3. *條件運算*: 比如 /CSEL/, /CCMP/ 等。
4. *其他的特殊操作*: 通常由處理器實現的 FEAT 相關，編解碼時由 *操作數* 數量區分。

具體的編碼表如下：

| Instr[28] | Instr[24:21]                       | Instr[15:10] | 相應指令分類                                                     |
|-----------+------------------------------------+--------------+------------------------------------------------------------------|
|         0 | 0b0xxx                             |              | 邏輯運算 (shifted register 類)                                   |
|         0 | 0b1xx0                             |              | 加減運算 (shifted register 類)                                   |
|         0 | 0b1xx1                             |              | 加減運算 (extended register 類)                                  |
|         1 | 0b0000                             | 0b000000     | 加減運算 (with carry 類)                                         |
|         1 | 0b0000                             | 0b001xxx     | 加減運算 (checked pointer 類，用於檢查指針運算是否超出範圍)      |
|         1 | 0b0000                             | 0bx00001     | Rotate right into flags 類 (數值右旋並改變處理器的 flags)        |
|         1 | 0b0000                             | 0bxx0010     | Evaluate into flags 類 (條件測試並改變處理器的conditional flags) |
|         1 | 0b0010                             | 0bxxxx0x     | 條件比較 (寄存器類)                                              |
|         1 | 0b0010                             | 0bxxxx1x     | 條件比較 (立即數類)                                              |
|         1 | 0b0100                             |              | 條件選擇 (例如 CSEL，允許根據條件標誌選擇不同的寄存器值)         |
|         1 | 0b0110, Instr[28]=0, Instr[30] = 1 |              | 單源操作數數據通路                                               |
|         1 | 0b0110, Instr[28]=0, Instr[30] = 0 |              | 雙源操作數數據通路                                               |
|         1 | 0b1xxx                             |              | 三源操作數數據通路                                               |

** 數據通路 - 立即數類
| Instr[30:29] | Instr[25:22] | 指令分類                                   |
|--------------+--------------+--------------------------------------------|
|              | 0b00xx       | PC 相對尋址 (PC-rel. addressing)           |
|              | 0b010x       | Add/substract                              |
|              | 0b0110       | Add/substract (with tags)，用於 *MTE* 拓展 |
|              | 0b0111       | Min/max                                    |
|              | 0b100x       | Logical                                    |
|              | 0b101x       | Move wide                                  |
|              | 0b110x       | Bitfield                                   |
| Not 0b11     | 0b111x       | Extract                                    |
| 0b11         | 0b111x       | 單源操作數數據通路                         |
** 內存加載和儲存
A64 有著極為獨特訪存模式以及豐富的訪存拓展，因此 Load/store 指令的數量也極為龐大。即使是基本 Load/store 指令，也有著不同的偏移量訪存模式。同時不同的特權級 (EL) 也有特定的訪存指令，而且拓展指令集也會帶來各自的訪存指令 (比如 SIMD)。因此會有一個特別上的 tag 段來進行編解碼。這裡給出相關的 Load/store 種類，而不給出具體的編解碼表。

1. 偏移量種類: 可以分為 /unsigned immediate/, /unscaled immediate/, /register offset/, /pre-indexed/, /post-indexed/ 等種類。
2. 成對加載/存儲: 比如 =LDP/STP= ，適用於 64-bit、128-bit。
3. 互斥訪存: 適用於多處理器環境中的 *同步與互斥* ，比如獨佔訪問 (=LDXR/STXR= exclusive register)、Compare and Swap (=CAS=)、Release-Compare-Write (=RCW CAS=)。
4. 內存順序保證 (/Ordered/): 這類指令確保訪存順序，通常用於內存屏障和同步機制。比如 (=STLR= store-release, =LDAPR= load-acquire)
5. Memory Tagging: Arm 引入了 /Memory Tagging Extension (MTE)/ 機制用於內存安全檢查。比如 (=LDG/STG= load/store tags)
6. 原子操作: 比如原子加法 (=LDADD/STADD=)，原子復位 (=LDCLR/STCLR=) 等。

一些 Armv8 的 FEAT 也會引入特殊用途的訪存指令，比如 /Pointer Authentication Code/, /General Capability System/ 等。
** 分支指令、異常生成和系統指令

/Branches, Exception Generating, and System Instructions/ 指令集大概可以分為一下幾類並以此編解碼：
1. *分支指令*: 包括條件、無條件分支、基於比較的分支等，同時也可以根據源操作數種類進行劃分。
2. *異常生成指令*: 這些指令用於產生異常 (/Exception/)，以實現系統調用、調試或錯誤處理。包括： =SVC=, =HVC=, =BRK= 等等。
3. *System Instructions (系統管理指令指令)* : 這類指令用於 _訪問處理器狀態 (/PSTATE/)_ 、 _執行特殊操作_ 、 _同步內存_ 等。
4. *Hints & Barriers*: 在 A64 系統指一些 *影響* CPU 的行為，但不會改變程式的 *邏輯結果* 。比如 /NOP/, /WFE/ 等 Hints 指令以及 /DSB/, /DMB/ 等內存屏障指令

由於這類指令數量較多且極易和常常拓展，同時理論上不需要多少源操作數，A64 足足用了 Instr[31:29] 和 Instr[25:12] 這麼長的譯碼空間。

** 浮點數、SIMD 指令
總得來說，A64 的 /Scalar Floating-Pointe and Advanced SIMD/ 可以分為三大類指令:
1. Cryptographic
2. Advenced SIMD
3. Floating-Point

Cryptographic 是大概分為 AES 和 SHA，並根據算法複雜性和步驟分為不同寄存器數量的指令 (如 two/three/four-register) 。

浮點數指令則分為 *Convention* 和浮點數的 *Data processing* ， /Advanced SIMD/ 則涉及一些更為復雜的數據通路及指令，比如 /across lanes/ (對整個向量求和或取最大值等)、 /table lookup/ 、 /permute/ 等

* 如何制作 X-Face 风格头像 :Emacs:nerd:
:PROPERTIES:
:EXPORT_FILE_NAME: how-to-make-and-use-xface
:EXPORT_HUGO_SECTION: posts
:EXPORT_DATE: 2025-02-17T01:23:06+08:00
:END:


一开始是在 /emacs-china/ 上水论坛时，经常能看到像素极低、纯黑白的头像、却又很带感的头像。后来[[https:emacs-china.org/t/topic/3118][发现]]原来叫 =X-face= ，大概是邮件／新闻组时代流行的头像。

#+begin_quote
翻到 [[https://blog.csdn.net/lujun9972/article/details/46002803][DarkSun转的一篇老文章]]，提到了 [[https://en.wikipedia.org/wiki/X-Face][X-Face]] 这个邮件／新闻组时代很流行的东西。就和现在的 Gravatar 差不多。甚至以前的 IRC 也能显示 X-face 头像。
#+end_quote

=X-face= 是邮件 header 部分嵌入的一段代码，在读入邮件时转换为 /48x48/ 的 bitmap。可以通过 [[https://www.dairiki.org/xface/xface.php][Online X-Face Converter]] 直接转换。然而，如果你的图片是彩色的、分辨率过高，直接转换的效果很不好。

这里参考了 [[https://emacs-china.org/t/x-face/28144][emacs-china 上的一个教程]]，分享一下作为 =gimp= 苦手的制作过程。

1. 图像->模式->灰度：将彩色的图片去色便于后续通过 *阈值* 分割像素，当然最好用本来就是黑白的图片。
2. 颜色->阈值：这一步将黑白像素分离，只要有线条即可，后续通过滤镜加粗线条。这里建议可以分图层处理，比如说眼睛部分和头发部分，往往当眼睛部分已经全为黑色像素时头发的线条还未区分。
3. 图像->模式->索引：将图片变为 /black and white pattle(1bit)/
4. 滤镜->常规->腐蚀：将线条加粗，一般需要多次使用这个滤镜。
5. 图像->缩放：缩放为 48x48 ，插值方法一般不限。

据 [[https://emacs-china.org/t/x-face/28144/2][LdBeth]]，x-face 没有确切的解码标准，甚至因为作者技术问题和导致仿造实现时出了偏差，有些实现是相互不兼容的，现在一般用 compface 这个具体实现。这里直接使用 /compface/ 提供的 =xbm2xface= 脚本即可。或者直接使用 [[https://www.dairiki.org/xface/xface.php][Online X-Face Converter]] encode一下。

** 为 WanderLust 设置 X-Face 邮件头

/WanderLust/ 自动读取 =~/.xface= ，如果需要显示 X-Face 则需要额外的包，参考了 =doom emacs= ，添加：

#+begin_src elisp
  ;; Use x-face only when compface installed
  (when (modulep! +xface)
    (autoload 'x-face-decode-message-header "x-face-e21")
    (setq wl-highlight-x-face-function 'x-face-decode-message-header))
#+end_src

顺便一提， =Homebrew= 目前不提供 =compface= 这个包，这里参考 [[https://www.linuxfromscratch.org/blfs/view/git/general/compface.html][Linux® From Scratch]] 手动构建了这个程序。你可能需要：

#+begin_src shell
sed -e '/compface.h/a #include <unistd.h>' \
    -i cmain.c                             \
    -i uncmain.c
#+end_src

才能构建成功。

* [譯] 高效文本編輯的七個習慣 :Emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: seven-habits-of-effective-text-editing
:EXPORT_HUGO_SECTION: posts
:EXPORT_DATE: <2025-03-15 Sat>
:END:

如果你花費大量時間輸入純文本、編寫程序或HTML，那麽通過使用一款優秀的編輯器並高效地使用它，你可以節省大量時間。本文將提供一些指導和建議，幫助你更快地完成工作並減少錯誤。

這里將使用開源文本編輯器Vim（Vi IMproved）來展示高效編輯的理念，但這些理念同樣適用於其他編輯器。 _選擇一款合適的編輯器_ 實際上是實現高效編輯的第一步。關於哪款編輯器最適合你的討論會占用太多篇幅，因此這里不做展開。如果你不知道該使用哪款編輯器，或者對當前使用的編輯器不滿意，不妨試試Vim /（譯者：不妨試試 *Emacs* ）/ ；你不會失望的。

#+begin_quote
原文標題：Seven habits of effective text editing

原文鏈接：[[https://www.moolenaar.net/habits.html]]

原文作者：[[https://www.moolenaar.net][Bram Moolenaar]]
#+end_quote

** Part 1: 單文件編輯
*** 1. 快速移動

在編輯文本時，大多數時間都花在 *閱讀* 、 *檢查錯誤* 以及 *尋找需要編輯的位置* 上，而不是插入或修改新文本。由於在文本中導航是非常頻繁的操作，因此你應該學會如何 _快速移動_ 。

很多時候，你會想要搜索一些你知道存在的文本，或者查看某個單詞或短語出現的所有行。你可以簡單地使用搜索命令 =/pattern= 來查找文本，但還有更聰明的方法：

- 如果你看到一個特定的單詞，並想搜索該單詞的其他出現位置，可以使用 =*= 命令。它會從光標下提取單詞並搜索下一個匹配項。
- 如果你設置了 =incsearch= 選項，Vim 會在你輸入模式時顯示第一個匹配項。這可以快速發現模式中的 _拼寫錯誤_ 。
- 如果你設置了 =hlsearch= 選項，Vim 會用黃色背景高亮顯示所有匹配項。這可以快速預覽搜索命令會帶你到哪里。在程序代碼中，它可以顯示變量的 _使用位置_ 。你甚至不需要移動光標就能看到匹配項。

在 /結構化文本/ 中，還有更多快速移動的可能性。Vim 為 C 語言（以及類似語言如 C++ 和 Java）提供了特定的命令：

- 使用 =%= 可以從一個開括號跳轉到其匹配的閉括號，或者從 =#if= 跳轉到匹配的 =#endif= 。實際上， =%= 可以跳轉到許多不同的匹配項。它對於檢查 =()= 和 ={}= 結構是否平衡非常有用。
- 使用 =[{= 可以跳回到當前代碼塊開頭的 ={= 。
- 使用 =gd= 可以從變量的使用位置跳轉到其局部聲明。

當然，還有很多其他命令。關鍵在於你需要熟悉這些命令。你可能會反對說，你不可能學會所有這些命令——有數百種不同的移動命令，有些簡單，有些非常巧妙——而且需要數周的訓練才能掌握它們。其實你不需要 *全部學會* ；相反，你應該意識到自己的編輯方式，並只學習那些 _能讓你的編輯更高效的命令_ 。

以下是三個基本步驟：

1. 在編輯時，留意你重覆執行的操作或花費大量時間的操作。
2. 查找是否有編輯器命令可以更快地完成這些操作。閱讀文檔、詢問朋友，或者觀察其他人是如何做的。
3. 練習使用這些命令，直到你能不假思索地輸入它們。

讓我們通過一個例子來說明它是如何工作的：

- 你發現自己在編輯 C 程序文件時，經常花費時間尋找函數的定義位置。你目前使用 =*= 命令搜索函數名的其他出現位置，但最終會瀏覽許多函數使用的位置，而不是定義位置。你意識到一定有更快的方法。
- 瀏覽快速參考時，你發現了一個關於跳轉到標簽的備注。文檔展示了如何用它跳轉到函數定義，這正是你想要的！
- 你嘗試使用 Vim 自帶的 =ctags= 程序生成標簽文件。你學會了使用 =CTRL-]= 命令，並發現它節省了大量時間。為了更方便，你在 Makefile 中添加了幾行代碼，以自動生成標簽文件。

在使用這三個步驟時，需要注意以下幾點：

- “我想完成工作，沒時間查閱文檔找新命令”。如果你這樣想，你會停留在計算的石器時代。有些人用記事本做所有事情，然後奇怪為什麽其他人能在一半的時間內完成工作…… 不要過猶不及。如果你總是試圖為每一件小事找到完美的命令，你的大腦將沒有時間思考你實際在做的工作。只需挑選那些花費不必要時間的操作，並練習這些命令，直到使用時無需思考。然後你就可以專注於文本了。

在接下來的部分中，將提供一些大多數人需要處理的操作建議。你可以將這些作為靈感，將 *三個基本步驟* 應用到自己的工作中。

*** 2. 不要重覆輸入

我們輸入的單詞是有限的，甚至短語和句子也是有限的，尤其是在計算機程序中。顯然，你不想重覆輸入相同的內容。

很多時候，你會想將一個單詞更改為另一個單詞。如果需要在整個文件中進行更改，可以使用 =:s= （替換）命令。如果只需要更改少數位置，快速的方法是使用 =*= 命令找到下一個匹配項，並使用 =cw= 更改單詞。然後按 =n= 找到下一個單詞，並按 =.= （點）重覆 =cw= 命令。

=.= 命令會重覆上一次的更改。在這里，“更改”指的是插入、刪除或替換文本。能夠重覆這一操作是一個非常強大的機制。如果你圍繞它組織編輯，許多更改將只需按一下 =.= 鍵即可完成。注意不要在中間進行其他更改，因為它會替換你正在重覆的更改。相反，你可以使用 =m= 命令標記位置，繼續重覆更改，稍後再回到那里。

某些函數和變量名可能很難輸入。你能快速無誤地輸入 =XpmCreatePixmapFromData= 而不看參考嗎？ Vim 有一個補全機制，可以讓這變得容易得多。它會查找你正在編輯的文件中的單詞，以及 =#include= 的文件中的單詞。你可以輸入 =XpmCr= ，然後按 =CTRL-N= ，Vim 會將其擴展為 =XpmCreatePixmapFromData= 。這不僅節省了大量輸入，還避免了拼寫錯誤，以及編譯器報錯後需要修覆的麻煩。

當你需要多次輸入一個短語或句子時，有一種更快的方法。Vim 有一個錄制宏的機制。你可以輸入 =qa= 開始錄制到寄存器 =a= 中，然後像平常一樣輸入命令，最後按 =q= 停止錄制。當你想重覆錄制的命令時，輸入 =@a= 。共有 26 個寄存器可用於此操作。

通過錄制，你可以重覆許多不同的操作，而不僅僅是插入文本。當你知道要重覆某些操作時，請記住這一點。

錄制時需要注意的一點是，命令會完全按照你輸入的方式回放。在移動時，你必須記住，重覆命令時，移動的文本可能會有所不同。向左移動四個字符在錄制時可能有效，但在重覆命令時可能需要移動五個字符。通常需要使用命令移動文本對象（單詞、句子）或移動到特定字符。

當需要重覆的命令變得更覆雜時，一次性正確輸入它們會變得更加困難。這時，你應該編寫腳本或宏，而不是錄制它們。這對於創建代碼部分的模板非常有用，例如函數頭。你可以根據需要使其盡可能智能。

*** 3. 快速修復錯誤

在輸入時犯錯是很正常的，沒有人能避免。關鍵在於快速發現並糾正這些錯誤。編輯器應該能夠幫助你做到這一點，但你需要告訴它什麽是錯的，什麽是對的。

很多時候，你會一次又一次地犯同樣的錯誤。你的手指就是沒有按你的意圖行事。這可以通過縮寫來糾正。以下是一些例子：

#+begin_src vim
:abbr Lunix Linux
:abbr accross across
:abbr hte the
#+end_src

這些單詞會在你輸入後自動更正。

同樣的機制也可以用來通過幾個字符輸入一個長單詞。這對於你難以輸入的單詞特別有用，同時也能避免輸入錯誤。例如：

#+begin_src vim
:abbr pn penguin
:abbr MS Mandrake Software
#+end_src

然而，這些縮寫有時會在你不希望的時候擴展為完整單詞，這在你確實想在文本中插入“MS”時會變得困難。最好使用沒有獨立意義的短單詞。

為了發現文本中的錯誤，Vim 有一個智能的高亮機制。這原本是用於程序語法高亮的，但它也可以捕捉並高亮錯誤。

語法高亮會用顏色顯示注釋。這聽起來不像是一個重要的功能，但一旦你開始使用它，你會發現它非常有幫助。你可以快速發現應該是注釋但沒有被高亮的文本（可能是你忘記了注釋標記），或者看到一行代碼被高亮為注釋（你可能忘記插入 =*/= ）。這些錯誤在黑白文件中很難發現，可能會在調試代碼時浪費大量時間。

語法高亮還可以捕捉不平衡的括號。一個不平衡的 =)= 會用亮紅色背景高亮顯示。你可以使用 =%= 命令查看它們如何匹配，並在正確的位置插入 =(= 或 =)= 。

其他常見錯誤也能快速發現，例如使用 =#included <stdio.h>= 而不是 =#include <stdio.h>= 。在黑白文件中，你很容易忽略這個錯誤，但通過高亮，你可以快速發現 =include= 被高亮而 =included= 沒有。

一個更覆雜的例子：對於英文文本，有一個包含所有使用單詞的長列表。任何不在這個列表中的單詞都可能是錯誤的。通過語法文件，你可以高亮所有不在列表中的單詞。通過一些額外的宏，你可以將單詞添加到單詞列表中，這樣它們就不會再被標記為錯誤。這與你在文字處理器中的預期效果一致。在 Vim 中，這是通過腳本實現的，你可以根據自己的需求進一步調整：例如，只檢查程序中的注釋是否有拼寫錯誤。

** Part 2: 多文件編輯
*** 4. 文件很少單獨存在

人們通常不會只處理一個文件。大多數情況下，會有許多相關的文件，你需要依次編輯多個文件，甚至同時編輯多個文件。你應該能夠利用編輯器的功能，使處理多個文件更加高效。

前面提到的 tag 機制也適用於在文件之間跳轉。通常的做法是為整個項目生成一個 tag 文件。然後，你可以在項目中的所有文件之間快速跳轉，查找函數、結構體、typedef 等的定義。與手動搜索相比，這節省了大量時間；瀏覽程序時，我做的第一件事就是生成 tag 文件。

另一個強大的機制是使用 =:grep= 命令在一組文件中查找某個名稱的所有出現位置。Vim 會列出所有匹配項，並跳轉到第一個匹配項。 =:cn= 命令會將你帶到下一個匹配項。如果你需要更改函數調用中的參數數量，這將非常有用。

頭文件（include files）中有很多有用的信息。但找到包含你所需聲明的文件可能會花費大量時間。Vim 了解包含文件，並可以在其中搜索你正在查找的單詞。最常見的操作是查找函數的原型。將光標放在文件中函數名稱上，然後輸入 =[I= ：Vim 會顯示包含文件中該函數名稱的所有匹配項。如果你需要查看更多上下文，可以直接跳轉到聲明處。類似的命令還可以用於檢查你是否包含了正確的頭文件。

在 Vim 中，你可以將文本區域分割成多個部分來編輯不同的文件。然後，你可以比較兩個或多個文件的內容，並在它們之間覆制/粘貼文本。有許多命令可以打開和關閉窗口、在窗口之間跳轉、臨時隱藏文件等。同樣，你需要使用三個基本步驟來選擇你想學習和使用的命令集。

多窗口還有更多用途。預覽 tag 機制就是一個很好的例子。它會打開一個特殊的預覽窗口，同時保持光標在你正在編輯的文件中。預覽窗口中的文本會顯示光標下函數名稱的函數聲明。如果你將光標移動到另一個名稱並停留一秒鐘，預覽窗口將顯示該名稱的定義。它也可能是項目中包含文件中聲明的結構體或函數的名稱。

*** 5. 協同編輯

編輯器用於編輯文本，電子郵件程序用於發送和接收消息，操作系統用於運行程序。每個程序都有自己的任務，並且應該擅長於此。真正的力量來自於讓這些程序協同工作。

一個簡單的例子：你需要寫一篇不超過 500 字的摘要。選擇當前段落並將其寫入 =wc= 程序： =vip:w !wc -w= 。外部的 =wc -w= 命令用於統計字數。很簡單，不是嗎？

總會有一些你需要的功能不在編輯器中。通過讓編輯器能夠用其他程序過濾文本，意味著你可以從外部添加這些功能。Unix 的精神一直是讓獨立的程序做好自己的工作，並協同完成更大的任務。不幸的是，大多數編輯器並不能很好地與其他程序協同工作——例如，你無法將 Netscape 中的電子郵件編輯器替換為另一個編輯器。最終你只能使用一個功能受限的編輯器。另一種趨勢是將各種功能集成到編輯器中；Emacs 就是一個很好的例子。（有些人稱其為“一個也可以用來編輯文本的操作系統”。）

Vim 試圖與其他程序集成，但這仍然是一個挑戰。目前，Vim 可以在 MS-Developer Studio 和 Sniff 中作為編輯器使用。一些支持外部編輯器的電子郵件程序（如 Mutt）也可以使用 Vim。與 Sun Workshop 的集成正在開發中。總的來說，這是一個在不久的將來需要改進的領域。只有這樣，我們才能得到一個比各部分總和更好的系統。

*** 6. 文本結構

你經常會處理具有某種結構的文本，但這些結構與現有命令支持的結構不同。這時，你需要回到編輯器的“構建模塊”，創建自己的宏和插件來處理這些文本。我們正在進入更覆雜的內容。

其中一個較簡單的任務是加速編輯-編譯-修覆的循環。Vim 提供了 =:make= 命令，它可以啟動編譯，捕獲編譯產生的錯誤，並讓你跳轉到錯誤位置進行修覆。如果你使用不同的編譯器，錯誤信息可能無法被識別。與其回到舊的“手動記錄”系統，你應該調整 =errorformat= 選項。這告訴 Vim 你的錯誤信息是什麽樣子的，以及如何從中提取文件名和行號。它適用於覆雜的 gcc 錯誤信息，因此你應該能夠讓它適用於幾乎任何編譯器。

有時，適應某種文件類型只需設置一些選項或編寫一些宏。例如，要在手冊頁之間跳轉，你可以編寫一個宏，抓取光標下的單詞，清空緩沖區，然後將該單詞的手冊頁讀入緩沖區。這是一種簡單高效的查找交叉引用的方法。

使用三個基本步驟，你可以更有效地處理任何類型的結構化文件。只需思考你想對文件執行的操作，找到執行這些操作的編輯器命令，並開始使用它們。這真的像聽起來那麽簡單。你只需要去做。

** Part 3: 必先利其器
*** 7. 養成習慣

學習開車需要付出努力。這是你繼續騎自行車的理由嗎？不，你意識到需要投入時間來學習一項技能。文本編輯也不例外。你需要學習新的命令並將其變成習慣。

另一方面，你不應該試圖學習編輯器提供的每一個命令。那將完全是浪費時間。大多數人只需要學習 10% 到 20% 的命令來完成他們的工作。但每個人需要的命令集是不同的。這需要你時不時停下來思考，是否有某些重覆性任務可以自動化。如果你只執行一次某個任務，並且不期望再次執行它，那就不要嘗試優化它。但你可能會意識到，你在過去一小時里已經重覆了某些操作好幾次。這時，你應該查閱文檔，尋找可以更快完成任務的命令，或者編寫一個宏來實現它。如果是一個更大的任務，比如處理某種特定類型的文本，你可以在新聞組或互聯網上看看是否有人已經為你解決了這個問題。

最關鍵的基本步驟是最後一步。你可能會想到一個重覆性任務，找到一個很好的解決方案，但過了一個周末後，你卻忘記了具體做法。這行不通。你必須重覆使用這個解決方案，直到你的手指能夠自動完成它。只有這樣，你才能達到所需的效率。不要試圖一次學習太多東西，但同時學習幾件事是可行的。對於那些你不常使用、無法熟練掌握的技巧，你可以將它們寫下來，以便以後查閱。無論如何，只要你心中有目標，你就會找到方法，讓你的編輯變得越來越高效。

最後提醒一下，如果人們忽視以上所有建議，會發生什麽：我仍然看到有些人每天花半天時間盯著屏幕，低頭看著兩根手指，再擡頭看屏幕，如此反覆——然後奇怪為什麽他們會這麽累…… *用十根手指打字* 這不僅更快，而且也更不容易疲勞。每天使用計算機程序一小時，只需要幾周時間就能學會盲打。
