<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>[譯] 高效文本编辑的七个习惯 - Fuloido&#39;s Blog</title><link rel="icon" type="image/png" href=/favicon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="如果你花费大量时间输入纯文本、编写程序或HTML，那么通过使用一款优秀的编辑器并高效地使用它，你可以节省大量时间。本文将提供一些指导和建议，帮助你更快地完成工作并减少错误。
这里将使用开源文本编辑器Vim（Vi IMproved）来展示高效编辑的理念，但这些理念同样适用于其他编辑器。 选择一款合适的编辑器 实际上是实现高效编辑的第一步。关于哪款编辑器最适合你的讨论会占用太多篇幅，因此这里不做展开。如果你不知道该使用哪款编辑器，或者对当前使用的编辑器不满意，不妨试试Vim （譯者：不妨試試 Emacs ） ；你不会失望的。

原文標題：Seven habits of effective text editing
原文鏈接：https://www.moolenaar.net/habits.html
原文作者：Bram Moolenaar

Part 1: 單文件編輯
1. 快速移动
在編輯文本時，大多数时间都花在 阅读 、 检查错误 以及 寻找需要编辑的位置 上，而不是插入或修改新文本。由于在文本中导航是非常频繁的操作，因此你应该学会如何 快速移动 。
很多时候，你会想要搜索一些你知道存在的文本，或者查看某个单词或短语出现的所有行。你可以简单地使用搜索命令 /pattern 来查找文本，但还有更聪明的方法：

如果你看到一个特定的单词，并想搜索该单词的其他出现位置，可以使用 * 命令。它会从光标下提取单词并搜索下一个匹配项。
如果你设置了 incsearch 选项，Vim 会在你输入模式时显示第一个匹配项。这可以快速发现模式中的 拼写错误 。
如果你设置了 hlsearch 选项，Vim 会用黄色背景高亮显示所有匹配项。这可以快速预览搜索命令会带你到哪里。在程序代码中，它可以显示变量的 使用位置 。你甚至不需要移动光标就能看到匹配项。

在 结构化文本 中，还有更多快速移动的可能性。Vim 为 C 语言（以及类似语言如 C&#43;&#43; 和 Java）提供了特定的命令：

使用 % 可以从一个开括号跳转到其匹配的闭括号，或者从 #if 跳转到匹配的 #endif 。实际上， % 可以跳转到许多不同的匹配项。它对于检查 () 和 {} 结构是否平衡非常有用。
使用 [{ 可以跳回到当前代码块开头的 { 。
使用 gd 可以从变量的使用位置跳转到其局部声明。

当然，还有很多其他命令。关键在于你需要熟悉这些命令。你可能会反对说，你不可能学会所有这些命令——有数百种不同的移动命令，有些简单，有些非常巧妙——而且需要数周的训练才能掌握它们。其实你不需要 全部学会 ；相反，你应该意识到自己的编辑方式，并只学习那些 能让你的编辑更高效的命令 。" />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="http://localhost:1313/posts/seven-habits-of-effective-text-editing/">
  <meta property="og:site_name" content="Fuloido&#39;s Blog">
  <meta property="og:title" content="[譯] 高效文本编辑的七个习惯">
  <meta property="og:description" content="如果你花费大量时间输入纯文本、编写程序或HTML，那么通过使用一款优秀的编辑器并高效地使用它，你可以节省大量时间。本文将提供一些指导和建议，帮助你更快地完成工作并减少错误。
这里将使用开源文本编辑器Vim（Vi IMproved）来展示高效编辑的理念，但这些理念同样适用于其他编辑器。 选择一款合适的编辑器 实际上是实现高效编辑的第一步。关于哪款编辑器最适合你的讨论会占用太多篇幅，因此这里不做展开。如果你不知道该使用哪款编辑器，或者对当前使用的编辑器不满意，不妨试试Vim （譯者：不妨試試 Emacs ） ；你不会失望的。
原文標題：Seven habits of effective text editing
原文鏈接：https://www.moolenaar.net/habits.html
原文作者：Bram Moolenaar
Part 1: 單文件編輯 1. 快速移动 在編輯文本時，大多数时间都花在 阅读 、 检查错误 以及 寻找需要编辑的位置 上，而不是插入或修改新文本。由于在文本中导航是非常频繁的操作，因此你应该学会如何 快速移动 。
很多时候，你会想要搜索一些你知道存在的文本，或者查看某个单词或短语出现的所有行。你可以简单地使用搜索命令 /pattern 来查找文本，但还有更聪明的方法：
如果你看到一个特定的单词，并想搜索该单词的其他出现位置，可以使用 * 命令。它会从光标下提取单词并搜索下一个匹配项。 如果你设置了 incsearch 选项，Vim 会在你输入模式时显示第一个匹配项。这可以快速发现模式中的 拼写错误 。 如果你设置了 hlsearch 选项，Vim 会用黄色背景高亮显示所有匹配项。这可以快速预览搜索命令会带你到哪里。在程序代码中，它可以显示变量的 使用位置 。你甚至不需要移动光标就能看到匹配项。 在 结构化文本 中，还有更多快速移动的可能性。Vim 为 C 语言（以及类似语言如 C&#43;&#43; 和 Java）提供了特定的命令：
使用 % 可以从一个开括号跳转到其匹配的闭括号，或者从 #if 跳转到匹配的 #endif 。实际上， % 可以跳转到许多不同的匹配项。它对于检查 () 和 {} 结构是否平衡非常有用。 使用 [{ 可以跳回到当前代码块开头的 { 。 使用 gd 可以从变量的使用位置跳转到其局部声明。 当然，还有很多其他命令。关键在于你需要熟悉这些命令。你可能会反对说，你不可能学会所有这些命令——有数百种不同的移动命令，有些简单，有些非常巧妙——而且需要数周的训练才能掌握它们。其实你不需要 全部学会 ；相反，你应该意识到自己的编辑方式，并只学习那些 能让你的编辑更高效的命令 。">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-15T00:00:00+08:00">
    <meta property="article:modified_time" content="2025-03-15T17:47:31+08:00">
    <meta property="article:tag" content="Emacs">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="[譯] 高效文本编辑的七个习惯">
  <meta name="twitter:description" content="如果你花费大量时间输入纯文本、编写程序或HTML，那么通过使用一款优秀的编辑器并高效地使用它，你可以节省大量时间。本文将提供一些指导和建议，帮助你更快地完成工作并减少错误。
这里将使用开源文本编辑器Vim（Vi IMproved）来展示高效编辑的理念，但这些理念同样适用于其他编辑器。 选择一款合适的编辑器 实际上是实现高效编辑的第一步。关于哪款编辑器最适合你的讨论会占用太多篇幅，因此这里不做展开。如果你不知道该使用哪款编辑器，或者对当前使用的编辑器不满意，不妨试试Vim （譯者：不妨試試 Emacs ） ；你不会失望的。
原文標題：Seven habits of effective text editing
原文鏈接：https://www.moolenaar.net/habits.html
原文作者：Bram Moolenaar
Part 1: 單文件編輯 1. 快速移动 在編輯文本時，大多数时间都花在 阅读 、 检查错误 以及 寻找需要编辑的位置 上，而不是插入或修改新文本。由于在文本中导航是非常频繁的操作，因此你应该学会如何 快速移动 。
很多时候，你会想要搜索一些你知道存在的文本，或者查看某个单词或短语出现的所有行。你可以简单地使用搜索命令 /pattern 来查找文本，但还有更聪明的方法：
如果你看到一个特定的单词，并想搜索该单词的其他出现位置，可以使用 * 命令。它会从光标下提取单词并搜索下一个匹配项。 如果你设置了 incsearch 选项，Vim 会在你输入模式时显示第一个匹配项。这可以快速发现模式中的 拼写错误 。 如果你设置了 hlsearch 选项，Vim 会用黄色背景高亮显示所有匹配项。这可以快速预览搜索命令会带你到哪里。在程序代码中，它可以显示变量的 使用位置 。你甚至不需要移动光标就能看到匹配项。 在 结构化文本 中，还有更多快速移动的可能性。Vim 为 C 语言（以及类似语言如 C&#43;&#43; 和 Java）提供了特定的命令：
使用 % 可以从一个开括号跳转到其匹配的闭括号，或者从 #if 跳转到匹配的 #endif 。实际上， % 可以跳转到许多不同的匹配项。它对于检查 () 和 {} 结构是否平衡非常有用。 使用 [{ 可以跳回到当前代码块开头的 { 。 使用 gd 可以从变量的使用位置跳转到其局部声明。 当然，还有很多其他命令。关键在于你需要熟悉这些命令。你可能会反对说，你不可能学会所有这些命令——有数百种不同的移动命令，有些简单，有些非常巧妙——而且需要数周的训练才能掌握它们。其实你不需要 全部学会 ；相反，你应该意识到自己的编辑方式，并只学习那些 能让你的编辑更高效的命令 。">

        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="http://localhost:1313/css/dark.50b57e12d401420df23965fed157368aba37b76df0ecefd0b1ecd4da664f01a0.css"  disabled /><script type="text/javascript"
		src="http://localhost:1313/js/MathJax.js"></script>
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script><link rel="stylesheet" href="http://localhost:1313/katex/katex.min.css ">
		<script defer src="http://localhost:1313/katex/katex.min.js"></script>
		<script defer src="http://localhost:1313/katex/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
		</script>
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">Fuloido&#39;s Blog</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/about">About</a>
		
		<a href="/tags">Tags</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#sun" />
</svg></span>
		<script src="http://localhost:1313/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">[譯] 高效文本编辑的七个习惯</h1>
          <div class="meta">Posted on Mar 15, 2025</div>
        </div>
        
        <section class="body">
          <p>如果你花费大量时间输入纯文本、编写程序或HTML，那么通过使用一款优秀的编辑器并高效地使用它，你可以节省大量时间。本文将提供一些指导和建议，帮助你更快地完成工作并减少错误。</p>
<p>这里将使用开源文本编辑器Vim（Vi IMproved）来展示高效编辑的理念，但这些理念同样适用于其他编辑器。 <span class="underline">选择一款合适的编辑器</span> 实际上是实现高效编辑的第一步。关于哪款编辑器最适合你的讨论会占用太多篇幅，因此这里不做展开。如果你不知道该使用哪款编辑器，或者对当前使用的编辑器不满意，不妨试试Vim <em>（譯者：不妨試試 <strong>Emacs</strong> ）</em> ；你不会失望的。</p>
<blockquote>
<p>原文標題：Seven habits of effective text editing</p>
<p>原文鏈接：<a href="https://www.moolenaar.net/habits.html">https://www.moolenaar.net/habits.html</a></p>
<p>原文作者：<a href="https://www.moolenaar.net">Bram Moolenaar</a></p>
</blockquote>
<h2 id="part-1-單文件編輯">Part 1: 單文件編輯</h2>
<h3 id="1-dot-快速移动">1. 快速移动</h3>
<p>在編輯文本時，大多数时间都花在 <strong>阅读</strong> 、 <strong>检查错误</strong> 以及 <strong>寻找需要编辑的位置</strong> 上，而不是插入或修改新文本。由于在文本中导航是非常频繁的操作，因此你应该学会如何 <span class="underline">快速移动</span> 。</p>
<p>很多时候，你会想要搜索一些你知道存在的文本，或者查看某个单词或短语出现的所有行。你可以简单地使用搜索命令 <code>/pattern</code> 来查找文本，但还有更聪明的方法：</p>
<ul>
<li>如果你看到一个特定的单词，并想搜索该单词的其他出现位置，可以使用 <code>*</code> 命令。它会从光标下提取单词并搜索下一个匹配项。</li>
<li>如果你设置了 <code>incsearch</code> 选项，Vim 会在你输入模式时显示第一个匹配项。这可以快速发现模式中的 <span class="underline">拼写错误</span> 。</li>
<li>如果你设置了 <code>hlsearch</code> 选项，Vim 会用黄色背景高亮显示所有匹配项。这可以快速预览搜索命令会带你到哪里。在程序代码中，它可以显示变量的 <span class="underline">使用位置</span> 。你甚至不需要移动光标就能看到匹配项。</li>
</ul>
<p>在 <em>结构化文本</em> 中，还有更多快速移动的可能性。Vim 为 C 语言（以及类似语言如 C++ 和 Java）提供了特定的命令：</p>
<ul>
<li>使用 <code>%</code> 可以从一个开括号跳转到其匹配的闭括号，或者从 <code>#if</code> 跳转到匹配的 <code>#endif</code> 。实际上， <code>%</code> 可以跳转到许多不同的匹配项。它对于检查 <code>()</code> 和 <code>{}</code> 结构是否平衡非常有用。</li>
<li>使用 <code>[{</code> 可以跳回到当前代码块开头的 <code>{</code> 。</li>
<li>使用 <code>gd</code> 可以从变量的使用位置跳转到其局部声明。</li>
</ul>
<p>当然，还有很多其他命令。关键在于你需要熟悉这些命令。你可能会反对说，你不可能学会所有这些命令——有数百种不同的移动命令，有些简单，有些非常巧妙——而且需要数周的训练才能掌握它们。其实你不需要 <strong>全部学会</strong> ；相反，你应该意识到自己的编辑方式，并只学习那些 <span class="underline">能让你的编辑更高效的命令</span> 。</p>
<p>以下是三个基本步骤：</p>
<ol>
<li>在编辑时，留意你重复执行的操作或花费大量时间的操作。</li>
<li>查找是否有编辑器命令可以更快地完成这些操作。阅读文档、询问朋友，或者观察其他人是如何做的。</li>
<li>练习使用这些命令，直到你能不假思索地输入它们。</li>
</ol>
<p>让我们通过一个例子来说明它是如何工作的：</p>
<ul>
<li>你发现自己在编辑 C 程序文件时，经常花费时间寻找函数的定义位置。你目前使用 <code>*</code> 命令搜索函数名的其他出现位置，但最终会浏览许多函数使用的位置，而不是定义位置。你意识到一定有更快的方法。</li>
<li>浏览快速参考时，你发现了一个关于跳转到标签的备注。文档展示了如何用它跳转到函数定义，这正是你想要的！</li>
<li>你尝试使用 Vim 自带的 <code>ctags</code> 程序生成标签文件。你学会了使用 <code>CTRL-]</code> 命令，并发现它节省了大量时间。为了更方便，你在 Makefile 中添加了几行代码，以自动生成标签文件。</li>
</ul>
<p>在使用这三个步骤时，需要注意以下几点：</p>
<ul>
<li>“我想完成工作，没时间查阅文档找新命令”。如果你这样想，你会停留在计算的石器时代。有些人用记事本做所有事情，然后奇怪为什么其他人能在一半的时间内完成工作…… 不要過猶不及。如果你总是试图为每一件小事找到完美的命令，你的大脑将没有时间思考你实际在做的工作。只需挑选那些花费不必要时间的操作，并练习这些命令，直到使用时无需思考。然后你就可以专注于文本了。</li>
</ul>
<p>在接下来的部分中，将提供一些大多数人需要处理的操作建议。你可以将这些作为灵感，将 <strong>三个基本步骤</strong> 应用到自己的工作中。</p>
<h3 id="2-dot-不要重复输入">2. 不要重复输入</h3>
<p>我们输入的单词是有限的，甚至短语和句子也是有限的，尤其是在计算机程序中。显然，你不想重复输入相同的内容。</p>
<p>很多时候，你会想将一个单词更改为另一个单词。如果需要在整个文件中进行更改，可以使用 <code>:s</code> （替换）命令。如果只需要更改少数位置，快速的方法是使用 <code>*</code> 命令找到下一个匹配项，并使用 <code>cw</code> 更改单词。然后按 <code>n</code> 找到下一个单词，并按 <code>.</code> （点）重复 <code>cw</code> 命令。</p>
<p><code>.</code> 命令会重复上一次的更改。在这里，“更改”指的是插入、删除或替换文本。能够重复这一操作是一个非常强大的机制。如果你围绕它组织编辑，许多更改将只需按一下 <code>.</code> 键即可完成。注意不要在中间进行其他更改，因为它会替换你正在重复的更改。相反，你可以使用 <code>m</code> 命令标记位置，继续重复更改，稍后再回到那里。</p>
<p>某些函数和变量名可能很难输入。你能快速无误地输入 <code>XpmCreatePixmapFromData</code> 而不看参考吗？ Vim 有一个补全机制，可以让这变得容易得多。它会查找你正在编辑的文件中的单词，以及 <code>#include</code> 的文件中的单词。你可以输入 <code>XpmCr</code> ，然后按 <code>CTRL-N</code> ，Vim 会将其扩展为 <code>XpmCreatePixmapFromData</code> 。这不仅节省了大量输入，还避免了拼写错误，以及编译器报错后需要修复的麻烦。</p>
<p>当你需要多次输入一个短语或句子时，有一种更快的方法。Vim 有一个录制宏的机制。你可以输入 <code>qa</code> 开始录制到寄存器 <code>a</code> 中，然后像平常一样输入命令，最后按 <code>q</code> 停止录制。当你想重复录制的命令时，输入 <code>@a</code> 。共有 26 个寄存器可用于此操作。</p>
<p>通过录制，你可以重复许多不同的操作，而不仅仅是插入文本。当你知道要重复某些操作时，请记住这一点。</p>
<p>录制时需要注意的一点是，命令会完全按照你输入的方式回放。在移动时，你必须记住，重复命令时，移动的文本可能会有所不同。向左移动四个字符在录制时可能有效，但在重复命令时可能需要移动五个字符。通常需要使用命令移动文本对象（单词、句子）或移动到特定字符。</p>
<p>当需要重复的命令变得更复杂时，一次性正确输入它们会变得更加困难。这时，你应该编写脚本或宏，而不是录制它们。这对于创建代码部分的模板非常有用，例如函数头。你可以根据需要使其尽可能智能。</p>
<h3 id="3-dot-快速修復錯誤">3. 快速修復錯誤</h3>
<p>在输入时犯错是很正常的，没有人能避免。关键在于快速发现并纠正这些错误。编辑器应该能够帮助你做到这一点，但你需要告诉它什么是错的，什么是对的。</p>
<p>很多时候，你会一次又一次地犯同样的错误。你的手指就是没有按你的意图行事。这可以通过缩写来纠正。以下是一些例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-vim" data-lang="vim"><span style="display:flex;"><span>:<span style="color:#a6e22e">abbr</span> <span style="color:#a6e22e">Lunix</span> <span style="color:#a6e22e">Linux</span>
</span></span><span style="display:flex;"><span>:<span style="color:#a6e22e">abbr</span> <span style="color:#a6e22e">accross</span> <span style="color:#a6e22e">across</span>
</span></span><span style="display:flex;"><span>:<span style="color:#a6e22e">abbr</span> <span style="color:#a6e22e">hte</span> <span style="color:#a6e22e">the</span>
</span></span></code></pre></div><p>这些单词会在你输入后自动更正。</p>
<p>同样的机制也可以用来通过几个字符输入一个长单词。这对于你难以输入的单词特别有用，同时也能避免输入错误。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-vim" data-lang="vim"><span style="display:flex;"><span>:<span style="color:#a6e22e">abbr</span> <span style="color:#a6e22e">pn</span> <span style="color:#a6e22e">penguin</span>
</span></span><span style="display:flex;"><span>:<span style="color:#a6e22e">abbr</span> <span style="color:#a6e22e">MS</span> <span style="color:#a6e22e">Mandrake</span> <span style="color:#a6e22e">Software</span>
</span></span></code></pre></div><p>然而，这些缩写有时会在你不希望的时候扩展为完整单词，这在你确实想在文本中插入“MS”时会变得困难。最好使用没有独立意义的短单词。</p>
<p>为了发现文本中的错误，Vim 有一个智能的高亮机制。这原本是用于程序语法高亮的，但它也可以捕捉并高亮错误。</p>
<p>语法高亮会用颜色显示注释。这听起来不像是一个重要的功能，但一旦你开始使用它，你会发现它非常有帮助。你可以快速发现应该是注释但没有被高亮的文本（可能是你忘记了注释标记），或者看到一行代码被高亮为注释（你可能忘记插入 <code>*/</code> ）。这些错误在黑白文件中很难发现，可能会在调试代码时浪费大量时间。</p>
<p>语法高亮还可以捕捉不平衡的括号。一个不平衡的 <code>)</code> 会用亮红色背景高亮显示。你可以使用 <code>%</code> 命令查看它们如何匹配，并在正确的位置插入 <code>(</code> 或 <code>)</code> 。</p>
<p>其他常见错误也能快速发现，例如使用 <code>#included &lt;stdio.h&gt;</code> 而不是 <code>#include &lt;stdio.h&gt;</code> 。在黑白文件中，你很容易忽略这个错误，但通过高亮，你可以快速发现 <code>include</code> 被高亮而 <code>included</code> 没有。</p>
<p>一个更复杂的例子：对于英文文本，有一个包含所有使用单词的长列表。任何不在这个列表中的单词都可能是错误的。通过语法文件，你可以高亮所有不在列表中的单词。通过一些额外的宏，你可以将单词添加到单词列表中，这样它们就不会再被标记为错误。这与你在文字处理器中的预期效果一致。在 Vim 中，这是通过脚本实现的，你可以根据自己的需求进一步调整：例如，只检查程序中的注释是否有拼写错误。</p>
<h2 id="part-2-多文件編輯">Part 2: 多文件編輯</h2>
<h3 id="4-dot-文件很少单独存在">4. 文件很少单独存在</h3>
<p>人们通常不会只处理一个文件。大多数情况下，会有许多相关的文件，你需要依次编辑多个文件，甚至同时编辑多个文件。你应该能够利用编辑器的功能，使处理多个文件更加高效。</p>
<p>前面提到的 tag 机制也适用于在文件之间跳转。通常的做法是为整个项目生成一个 tag 文件。然后，你可以在项目中的所有文件之间快速跳转，查找函数、结构体、typedef 等的定义。与手动搜索相比，这节省了大量时间；浏览程序时，我做的第一件事就是生成 tag 文件。</p>
<p>另一个强大的机制是使用 <code>:grep</code> 命令在一组文件中查找某个名称的所有出现位置。Vim 会列出所有匹配项，并跳转到第一个匹配项。 <code>:cn</code> 命令会将你带到下一个匹配项。如果你需要更改函数调用中的参数数量，这将非常有用。</p>
<p>頭文件（include files）中有很多有用的信息。但找到包含你所需声明的文件可能会花费大量时间。Vim 了解包含文件，并可以在其中搜索你正在查找的单词。最常见的操作是查找函数的原型。将光标放在文件中函数名称上，然后输入 <code>[I</code> ：Vim 会显示包含文件中该函数名称的所有匹配项。如果你需要查看更多上下文，可以直接跳转到声明处。类似的命令还可以用于检查你是否包含了正确的头文件。</p>
<p>在 Vim 中，你可以将文本区域分割成多个部分来编辑不同的文件。然后，你可以比较两个或多个文件的内容，并在它们之间复制/粘贴文本。有许多命令可以打开和关闭窗口、在窗口之间跳转、临时隐藏文件等。同样，你需要使用三个基本步骤来选择你想学习和使用的命令集。</p>
<p>多窗口还有更多用途。预览 tag 机制就是一个很好的例子。它会打开一个特殊的预览窗口，同时保持光标在你正在编辑的文件中。预览窗口中的文本会显示光标下函数名称的函数声明。如果你将光标移动到另一个名称并停留一秒钟，预览窗口将显示该名称的定义。它也可能是项目中包含文件中声明的结构体或函数的名称。</p>
<h3 id="5-dot-协同編輯">5. 协同編輯</h3>
<p>编辑器用于编辑文本，电子邮件程序用于发送和接收消息，操作系统用于运行程序。每个程序都有自己的任务，并且应该擅长于此。真正的力量来自于让这些程序协同工作。</p>
<p>一个简单的例子：你需要写一篇不超过 500 字的摘要。选择当前段落并将其写入 <code>wc</code> 程序： <code>vip:w !wc -w</code> 。外部的 <code>wc -w</code> 命令用于统计字数。很简单，不是吗？</p>
<p>总会有一些你需要的功能不在编辑器中。通过让编辑器能够用其他程序过滤文本，意味着你可以从外部添加这些功能。Unix 的精神一直是让独立的程序做好自己的工作，并协同完成更大的任务。不幸的是，大多数编辑器并不能很好地与其他程序协同工作——例如，你无法将 Netscape 中的电子邮件编辑器替换为另一个编辑器。最终你只能使用一个功能受限的编辑器。另一种趋势是将各种功能集成到编辑器中；Emacs 就是一个很好的例子。（有些人称其为“一个也可以用来编辑文本的操作系统”。）</p>
<p>Vim 试图与其他程序集成，但这仍然是一个挑战。目前，Vim 可以在 MS-Developer Studio 和 Sniff 中作为编辑器使用。一些支持外部编辑器的电子邮件程序（如 Mutt）也可以使用 Vim。与 Sun Workshop 的集成正在开发中。总的来说，这是一个在不久的将来需要改进的领域。只有这样，我们才能得到一个比各部分总和更好的系统。</p>
<h3 id="6-dot-文本结构">6. 文本结构</h3>
<p>你经常会处理具有某种结构的文本，但这些结构与现有命令支持的结构不同。这时，你需要回到编辑器的“构建模块”，创建自己的宏和插件来处理这些文本。我们正在进入更复杂的内容。</p>
<p>其中一个较简单的任务是加速编辑-编译-修复的循环。Vim 提供了 <code>:make</code> 命令，它可以启动编译，捕获编译产生的错误，并让你跳转到错误位置进行修复。如果你使用不同的编译器，错误信息可能无法被识别。与其回到旧的“手动记录”系统，你应该调整 <code>errorformat</code> 选项。这告诉 Vim 你的错误信息是什么样子的，以及如何从中提取文件名和行号。它适用于复杂的 gcc 错误信息，因此你应该能够让它适用于几乎任何编译器。</p>
<p>有时，适应某种文件类型只需设置一些选项或编写一些宏。例如，要在手册页之间跳转，你可以编写一个宏，抓取光标下的单词，清空缓冲区，然后将该单词的手册页读入缓冲区。这是一种简单高效的查找交叉引用的方法。</p>
<p>使用三个基本步骤，你可以更有效地处理任何类型的结构化文件。只需思考你想对文件执行的操作，找到执行这些操作的编辑器命令，并开始使用它们。这真的像听起来那么简单。你只需要去做。</p>
<h2 id="part-3-必先利其器">Part 3: 必先利其器</h2>
<h3 id="7-dot-养成习惯">7. 养成习惯</h3>
<p>学习开车需要付出努力。这是你继续骑自行车的理由吗？不，你意识到需要投入时间来学习一项技能。文本编辑也不例外。你需要学习新的命令并将其变成习惯。</p>
<p>另一方面，你不应该试图学习编辑器提供的每一个命令。那将完全是浪费时间。大多数人只需要学习 10% 到 20% 的命令来完成他们的工作。但每个人需要的命令集是不同的。这需要你时不时停下来思考，是否有某些重复性任务可以自动化。如果你只执行一次某个任务，并且不期望再次执行它，那就不要尝试优化它。但你可能会意识到，你在过去一小时里已经重复了某些操作好几次。这时，你应该查阅文档，寻找可以更快完成任务的命令，或者编写一个宏来实现它。如果是一个更大的任务，比如处理某种特定类型的文本，你可以在新闻组或互联网上看看是否有人已经为你解决了这个问题。</p>
<p>最关键的基本步骤是最后一步。你可能会想到一个重复性任务，找到一个很好的解决方案，但过了一个周末后，你却忘记了具体做法。这行不通。你必须重复使用这个解决方案，直到你的手指能够自动完成它。只有这样，你才能达到所需的效率。不要试图一次学习太多东西，但同时学习几件事是可行的。对于那些你不常使用、无法熟练掌握的技巧，你可以将它们写下来，以便以后查阅。无论如何，只要你心中有目标，你就会找到方法，让你的编辑变得越来越高效。</p>
<p>最后提醒一下，如果人们忽视以上所有建议，会发生什么：我仍然看到有些人每天花半天时间盯着屏幕，低头看着两根手指，再抬头看屏幕，如此反复——然后奇怪为什么他们会这么累…… <strong>用十根手指打字</strong> 这不仅更快，而且也更不容易疲劳。每天使用计算机程序一小时，只需要几周时间就能学会盲打。</p>

        </section>
        <div class="post-tags">
          
          
          <nav class="nav tags">
            <ul class="tags">
              
              <li><a href="/tags/emacs">Emacs</a></li>
              
            </ul>
          </nav>
          
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/fuloido" rel="me" title="GitHub"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github" />
</svg></a><a class="border"></a></div>
  <div class="footer-info">
    2025  © Fuloido |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>

</div>
    </body>
</html>
